# The Structure of a Signature #

The Teyjus parser for signatures is a combination of a "pre-parser" automatically generated by the _OCaml_ parser generator from a context-free grammar and a post processor that manipulates the pre-abstract syntax structures generated from the grammar. The post processing phase is needed to handle information such as the arities of type constructors that is also gleaned through the (pre-)parse. The grammar below describes a syntax that is the sum total of these two phases. It is presented in this way to explicate signature syntax to the user of a system and is not to be confused with the context-free grammar description that is given to the parser generator.

## A BNF Specification of Signature Syntax ##

```
<Signature>    ::=   <SigHeader> <SigPreamble> <Sign-Decls> <SigEnd>

<SigHeader>    ::=   'sig' <NameToken> '.'

<SigEnd>       ::=   'end' | '$'                 % $ stands for eof

<SigPreamble>  ::=   <Empty>
                   | accum_sig <NameTokens> '.' <SigPreamble>
                   | use_sig <NameTokens> '.' <SigPreamble>

<NameTokens>   ::=   <NameToken>
                   | <NameToken> ',' <NameTokens>

<Sign-Decls>   ::=   <Empty>
                   | <Sign-Decl> <Sign-Decls>

<Sign-Decl>    ::=   'kind'  <Ids>  <Kind> '.'
                   | 'typeabbrev' <AbbrForm> <Type> '.'
                   | 'type'  <Ids>  <Type> '.'
                   | <Fixity> <Ids> <SmallInt> '.'
                   | 'exportdef' <Ids> '.' 
                   | 'exportdef' <Ids> <Type> '.'
                   | 'useonly' <Ids> '.' 
                   | 'useonly' <Ids> <Type> '.'

<Ids>          ::=   <Id>
                   | <Id> ',' <Ids>

<Kind>         ::=   'type'
                   | 'type' '->' <Kind>

<AbbrForm>     ::=   <Id>
                   | '(' <Id> <NamedVarList> ')'
                   | '(' <AbbrForm> ')'

<NamedVarList> ::=   <NamedVar>
                   | <NamedVar> <NamedVarList>   

<Type>         ::=   <CType> '->' <Type>
                   | <CType>

<CType>        ::=   <NameToken>
                   | <TyCIdent> <CTypes>
                   | '(' <Type> ')'

<TyCIdent>     ::= <Id>

<CTypes>       ::=   <CType>
                   | <CType> <CTypes>

<Fixity>       ::=   'infixl' | 'infixr' | 'infix'
                   | 'prefix' | 'prefixr'
                   | 'postfix' | 'postfixl'

<NameToken>    ::=  { Any Teyjus token distinct from keywords,
                        pseudo-keywords, integer, string and real
                        literals }

<Id>           ::=  { Like NameToken, except that the token should 
                       also begin with something different from an 
                       uppercase letter and _ }

<NamedVar>     ::=  { Any named token that begins with an 
                      uppercase letter }
                       
<SmallInt>     ::=  { Integer value between 0 and 255; i.e. unsigned 
                     one byte number }

<Empty>        ::=  { empty token sequence }
```



## Commentary on Signature Syntax ##

The declarations in a signature file must satisfy certain properties in addition to being derivable from the grammar rules:

  * Each signature is expected to be presented in a distinct file. This file must have the name `<modname>.sig` where `<modname>` is the name of the relevant module and signature. This name should also coincide with the name indicated in the signature header, generated by the rule for `<SigHeader>`.

  * A signature may accumulate or use another signature via an _accum`_`sig_ or _use`_`sig_ declaration. Before it becomes meaningful to deem a given signature as well-formed, each of its accumulated and used signatures should be determined to be so by the same rules that are described in this commentary. Notice, in particular, that a modularity principle for signatures is implied by this: each signature must be understood independently and completely, i.e., the context of its accumulation or use has no impact on this understanding.

  * The intended effect of _accum`_`sig_ declarations is to include the declarations in the named signatures in the signature being generated from the text in the present file. Thus, _accum`_`sig_ functions in a manner similar to _#include_ in C. The possible interactions between sibling accumulated signatures and the accumulating signature are discussed further below.

  * Kind declarations are those expressions in the category `<Sign-Decl>` that begin with the token kind. The purpose of these declarations is to identify sorts and type constructors that may be used in determining types for constants and variables. Thus a declaration of the form
```
           kind  foo  type -> ... -> type
```

> with n+1 occurrences of type identifies foo as a type constructor of arity n. (If n is 0 the object identified is a sort.) Note that there are restrictions built into the grammar rules on the syntax of tokens that can be identified as sorts and type constructors.

  * Type abbreviation declarations are those expressions in the category `<Sign-Decl>` that begin with the token _typeabbrev_. The purpose of these declarations is to identify names that can be used as shorthands in type expressions. These names can also be parameterized. For example, a declaration of the form
```
          typeabbrev   (bar A)   list A -> list A
```

> allows _(bar int)_ to be used as an abbreviation for the expression _list int -> list int_ in the type expressions described below. There is a restriction on the type expressions that figure in such a declaration: any variable that is used in them must have been identified as a "parameter" of the name that is being identified as an abbreviation. This explanation has a "forward reference": in assumes an understanding of type expressions that appears later in this sequence.

  * Tokens that are identified as the names of abbreviations have an appearance in syntax that is similar to that of sorts and type constructors. We shall refer to all of these kinds of symbols collectively as type constants when there is no need to make finer distinctions.

  * Type declarations are those expressions in the category `<Sign-Decl>` that begin with the token _type_. Type declarations identify term constants with their associated types. Note that the constants for which types can be so declared have a limited syntax. In particular, they should not begin with an uppercase letter or the underscore (`_`) character.

  * Type expressions are constructed, as expected, from type constants, type variables and the arrow type constructor written as _->_. Tokens appearing in such expressions are classified as type variables or type constants depending on whether or not they begin with an uppercase letter or the underscore (`_`) character. In understanding the structure of potentially ambiguous type expressions, the following convention is to be used: the application of a type constructor to types is left associative and has higher precedence than the construction of an arrow type; i.e. _(tc ty1 ... tyn -> sort)_ is read as _((...(tc ty1)...tyn) -> sort)_.

  * A requirement for a type-expression to be well-formed is that every type constant that appears in it and that is not built-in must be previously defined. In determining this, (a) every sort, type constructor and type abbreviation defined in an accumulated or used signature is assumed to be available before any type expression in this signature is processed, (b) every sort and type constructor defined in this signature is assumed to be available before the type expression in any type abbreviation declaration is processed, (c) type abbreviations introduced by declarations physically preceding another such declaration are assumed to be available in interpreting the type expression in the new type abbreviation declaration and (d) every sort, type constructor and type abbreviation defined by a declaration in the signature is assumed to be available at the type a type declaration is processed.

  * Another requirement for a type expression to be well-formed is that every type constructor and every identifier that names an abbreviation that appears in it must be supplied with a full complement of argument types, i.e. the usage of a type constant must be consistent with its declaration.

  * A well-formed type expression denotes the type that is obtained by replacing each type abbreviation used within it by the fully expanded type expression that it corresponds to; what is meant by "expansion" in this context is discussed informally in the comment explaining type abbreviations and we expect that this notion is unambiguously understood at this point.

  * Operator declarations are those expressions in the category `<Sign-Decl>` that are further characterized by the form
```
       	 <Fixity> <Ids> <SmallInt> '.' 
```

> Such declarations identify relevant (term) constants as being infix, prefix or postfix operators that are not associative, left associative or right associative and having a specified precedence. Types of constants that are defined as operators must be consistent with their interpretation as such.

  * Exportdef and useonly declarations are expressions in the `<Sign-Decl>` category that begin with the tokens exportdef and useonly, respectively. exportdef and useonly declarations must pertain to predicate constants only, i.e. constants with a target type o. exportdef declarations identify the relevant constants as ones whose definitions emanating from the module associated with the signature must not change. useonly declarations play a complementary role: these identify predicates that might be used in the module associated with the signature but whose definitions cannot be further refined there. exportdef and useonly declarations can also identify types with the relevant constants. In this case, the type expressions must satisfy all the requirements required of them relative to type declarations of the usual form.

  * The intended effect of use`_`sig declarations is similar to that of accum`_`sig declarations with one change: every exportdef declaration appearing in the signature being included (or accumulated) must first be changed to a useonly declaration of the same constants. Intuitively, use`_`sig declarations serve to identify predicates (and associated constants and kinds) in the signature of a "consumer;" the change in annotation from exportdef to useonly signals that these predicates can be used but must not be redefined or extended in any code possessing the signature.

  * There must be at most one type, one kind or type abbreviation and one fixity identification per Id. There might be multiple declarations in each category for this Id but all must agree eventually within that category. Also, no predicate should be defined both useonly and exportdef in any given module.

  * Fixity declarations must be for constants defined in the signature.