# Characterization of Tokens in Teyjus #

We describe below the rules for recognizing tokens in the different relevant categories. Two points are relevant to mention prior to this description. First, as is standard, the principle of longest match is used in tokenization. The Teyjus lexical analyzer is in fact automatically generated by the _OCaml_ equivalent of _flex_, _ocamllex_, based on a regular grammar presentation of the tokens and token categories below. Second, a far fewer set of characters are treated as token separators than is usual. In particular, only the characters identified as punctuation symbols are interpreted in this manner over and above 'white space' characters. To take a specific example, a sequence such as _X+Y_ is interpreted as a token as opposed to a sequence of three tokens.


## Keywords ##

The following sequences of characters are recognized as tokens with a special meaning within Teyjus.

```
accum_sig   accumulate  closed      end         exportdef   import
infix       infixl      infixr      kind        local       localkind
module      postfix     posfixl     prefix      prefixr     sig
type        typeabbrev  use_sig     useonly     :-          =>
\           ->          !
```

## Other Special Tokens in Teyjus ##

The following tokens are ones that, in addition to the keywords and punctuation symbols, cannot be redefined by user programs. Some of these symbols---in particular, the symbols _pi_, _sigma_, _;_, _&_, _=>_, _=_, _::_ and _nil_---are constants and are like other identifiers except for the 'no redefinition' clause. The remaining symbols are overloaded and so are treated in a special way by the parser. Finally, some symbols, in particular _::_ and _nil_, receive a special treatment at the abstract machine level.

```
pi          sigma       ,           ;           &           =
+           -           *           /           ::          nil
~           <           >           =<          >=
```

## Punctuation ##

The following symbols serve as delimiters, grouping symbols, etc. Notice that comma appears in the list of pseudo keywords as well; usage is determined by context.

```
.          ,            (          )          :         [          
]          | 
```

## Identifiers and Variable Names ##

Any contiguous sequence of alphanumeric or sign characters different from the punctuation characters (i.e. any of the characters ``+-*/^<>=`'?@#$&!_~`` that begins with something other than a digit or the sequence /`*` constitutes a name. A name that begins with anything other than the underscore character may be used as that of a variable bound by an abstraction. Names other than those that begin with the underscore (`_`) character or an uppercase letter and those included in the special tokens category may be identified as constants through type declarations or sorts or type constructors through kind declarations. Such names are also interpreted as those of (local, undeclared) constants if they are used in clauses without a previous type declaration and they are not bound by enclosing abstractions. A name that begins with the underscore character or with an uppercase letter and that is not bound by an abstraction is considered to be that of a free (implicitly existentially quantified) variable.

Three points should be noted with regard to this definition. First, as already observed and unlike in most other languages, certain characters (like -, `*`, etc) are not treated as token separators in addition to being tokens. Thus, X-Y is a single token and not a sequence of three tokens. Second, some token sequences such as => and -> appear to be ambiguous, qualifying to be either keywords or names. This ambiguity is resolved by deeming the keyword interpretation to take precedence in all such cases. Finally, some names, such as pi and ::, are treated as special (overloaded or predefined) tokens and these cannot be reinterpreted through type declarations.

## Integer Literals ##

A sequence of digits is recognized as an integer constant. As usual, there are size limitations on integers. In the present implementation, the limitation is that the integer should fit in 32 bits.

## Real Literals ##

A sequence of digits followed by a period and then a sequence of digits is recognized as a real constant. The sequence before the period may be empty but the sequence after the period must be nonempty. The representation is based on 8 bit exponent and 23 bit fraction.

## String Literals ##

These are character sequences enclosed within two double quotes. We permit a mix of SICSTUS and ML syntax for strings. In particular, a string constant is a sequence enclosed between double quotes of zero or more printable characters numbered 33-126, spaces or escape sequences. All escape sequences barring one start with the character \ and stand for a character sequence. The escape sequences are:


| \a    |   Alert (ASCII 0x07)  |
|:------|:----------------------|
| \b    |   Backspace (ASCII 0x08) |
| \t    |   Horizontal tab (ASCII 0x09) |
| \n    |  Linefeed or newline (ASCII 0x0A) |
| \v    |  Vertical tab (ASCII 0x0B) |
| \f    |  Form feed (ASCII 0x0C) |
| \r    |  Carriage return (ASCII 0x0D) |
| \e    |   Escape (ASCII 0x1B) |
| \d    |  Delete (ASCII 0x7F) |
| \\    |   Backslash |
| \"    |  Double quote |
|  \^c  |    A control character whose encoding is C mod 32, where C is the encoding of the character c, with C in the range [64,122]. |
| \ddd  |   The character whose encoding is the number ddd, three decimal digits denoting an integer in the range [0,255]. |
| \xhh   |  The character whose encoding is the number hh, two hexadecimal digits, with a-f (A-F) denoting the 'digits' 10-15 respectively. |
| \f...f\  |This sequence is ignored, where f...f stands for a sequence of one or more formatting characters (that are currently restricted to horizontal and vertical tab, whitespace, newline and carriage return). |
| \c...  |  where ... stands for a sequence of formatting characters, ending with a non formatting character. This sequence is to be ignored.|


In the escape sequences involving decimal or hexadecimal digits, the sequence of digits is taken to be the longest sequence of such characters.

## The Syntax for Comments ##

Two styles for writing comments are supported. Multiline comments may be enclosed within a matched pair of /`*` and `*`/; nesting of comments is legal. Single line comments are preceded by % and extend to the end of the line.